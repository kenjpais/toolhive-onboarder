name: OLM Test (OKD Compatible)

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]
  workflow_dispatch:
    inputs:
      catalog_image:
        description: 'Catalog image to use'
        required: false
        default: 'quay.io/kpais/toolhive-test-catalog:latest'

env:
  OPERATOR_NS: toolhive-test-ns
  CATALOG_IMAGE: ${{ github.event.inputs.catalog_image || 'quay.io/kpais/toolhive-test-catalog:latest' }}
  TEST_TIMEOUT: 10m
  CLUSTER_NAME: toolhive-olm-test

jobs:
  olm-test:
    name: OLM Operator Test (OKD Compatible)
    runs-on: ubuntu-latest
    timeout-minutes: 30
    defaults:
      run:
        shell: bash
        working-directory: ${{ github.workspace }}
    
    steps:
      # Phase 2: CI Environment Setup
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.22'
      
      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Install Chainsaw
        uses: kyverno/action-install-chainsaw@v0.2.13
        with:
          release: v0.2.12
      
      - name: Install OpenShift CLI (oc) for OKD compatibility
        run: |
          set -e
          echo "Installing OpenShift CLI (oc) for OKD compatibility..."
          # Install OpenShift CLI compatible with OKD
          # Try multiple version paths for reliability
          OC_VERSION=4.15
          if ! curl -Lf https://mirror.openshift.com/pub/openshift-v4/clients/ocp/stable-${OC_VERSION}/openshift-client-linux.tar.gz -o /tmp/oc.tar.gz 2>/dev/null; then
            if ! curl -Lf https://mirror.openshift.com/pub/openshift-v4/clients/ocp/${OC_VERSION}/openshift-client-linux.tar.gz -o /tmp/oc.tar.gz 2>/dev/null; then
              # Fallback to latest stable
              curl -Lf https://mirror.openshift.com/pub/openshift-v4/clients/ocp/latest/openshift-client-linux.tar.gz -o /tmp/oc.tar.gz
            fi
          fi
          tar -xz -C /usr/local/bin -f /tmp/oc.tar.gz
          chmod +x /usr/local/bin/oc
          oc version --client
          echo "OpenShift CLI (oc) installed for OKD compatibility"
      
      - name: Verify kubectl and oc
        run: |
          set -e
          kubectl version --client
          oc version --client
          echo "kubectl and oc are available"
      
      # Phase 3: Cluster Provisioning and OLM Installation
      # Note: Using KIND with OLM installation to simulate OKD environment
      # KIND does not support full OKD distribution, but we simulate OKD by:
      # - Installing OLM (which OKD includes by default)
      # - Using OpenShift CLI (oc) for OKD-compatible operations
      # - Using OKD standard namespaces (openshift-marketplace)
      # In a real OKD cluster, OLM is pre-installed
      - name: Create KIND Cluster
        uses: helm/kind-action@v1.12.0
        with:
          cluster_name: ${{ env.CLUSTER_NAME }}
          version: v0.29.0
          node_image: kindest/node:v1.32.8
      
      - name: Configure kubectl and oc for KIND
        run: |
          set -e
          kind get kubeconfig --name ${{ env.CLUSTER_NAME }} > ${HOME}/.kube/config
          # Wait for cluster to be ready
          kubectl wait --for=condition=Ready node --all --timeout=120s
          kubectl cluster-info
          oc cluster-info || echo "Note: oc cluster-info may not work with KIND, but oc is available for OKD-compatible operations"
          echo "KIND cluster is ready (using OKD-compatible tooling)"
      
      - name: Install OLM CRDs (OKD includes OLM by default, but installing for KIND)
        run: |
          set -e
          echo "Installing OLM CRDs (simulating OKD environment where OLM is pre-installed)..."
          # Download CRDs file first
          curl -L https://github.com/operator-framework/operator-lifecycle-manager/releases/download/v0.28.0/crds.yaml -o /tmp/olm-crds.yaml
          # Use server-side apply to handle large CRDs with large annotations
          # This bypasses the client-side annotation size limit
          kubectl apply --server-side -f /tmp/olm-crds.yaml || kubectl apply --server-side --force-conflicts -f /tmp/olm-crds.yaml
          echo "OLM CRDs installed successfully"
      
      - name: Install OLM (OKD includes OLM by default, but installing for KIND)
        run: |
          set -e
          echo "Installing OLM components (simulating OKD environment where OLM is pre-installed)..."
          kubectl apply -f https://github.com/operator-framework/operator-lifecycle-manager/releases/download/v0.28.0/olm.yaml
          echo "OLM components installed"
      
      - name: Wait for OLM to be ready (OKD includes OLM by default)
        run: |
          set -e
          echo "Waiting for OLM operator deployment (OKD includes OLM by default)..."
          if ! oc wait --for=condition=available --timeout=5m deployment/olm-operator -n olm; then
            echo "ERROR: OLM operator deployment failed"
            oc get pods -n olm
            oc describe deployment/olm-operator -n olm
            exit 1
          fi
          
          echo "Waiting for catalog operator deployment..."
          if ! oc wait --for=condition=available --timeout=5m deployment/catalog-operator -n olm; then
            echo "ERROR: Catalog operator deployment failed"
            oc get pods -n olm
            oc describe deployment/catalog-operator -n olm
            exit 1
          fi
          
          echo "Waiting for packageserver deployment..."
          if ! oc wait --for=condition=available --timeout=5m deployment/packageserver -n olm; then
            echo "ERROR: Packageserver deployment failed"
            oc get pods -n olm
            oc describe deployment/packageserver -n olm
            exit 1
          fi
          
          echo "OLM is ready (OKD-compatible)"
      
      - name: Create openshift-marketplace namespace (OKD standard namespace)
        run: |
          set -e
          oc create namespace openshift-marketplace --dry-run=client -o yaml | oc apply -f -
          echo "openshift-marketplace namespace created (OKD standard namespace for CatalogSources)"
      
      # Phase 4: Catalog Image Preparation
      - name: Prepare catalog image
        run: |
          set -e
          echo "Using catalog image: ${{ env.CATALOG_IMAGE }}"
          
          # Verify image exists and check architecture
          echo "Verifying catalog image exists and architecture..."
          if ! docker pull ${{ env.CATALOG_IMAGE }}; then
            echo "ERROR: Failed to pull catalog image: ${{ env.CATALOG_IMAGE }}"
            echo "Please ensure the image exists and is accessible"
            exit 1
          fi
          
          # Check image architecture
          ARCH=$(docker inspect ${{ env.CATALOG_IMAGE }} --format '{{.Architecture}}' || echo "unknown")
          echo "Catalog image architecture: $ARCH"
          
          # Verify it's amd64/x86_64 (required for CI environment)
          if [ "$ARCH" != "amd64" ] && [ "$ARCH" != "x86_64" ]; then
            echo "ERROR: Catalog image architecture is $ARCH, but CI environment requires amd64/x86_64"
            echo "Please rebuild the catalog image for linux/amd64 architecture"
            echo "You can use the build-catalog workflow to rebuild it"
            exit 1
          fi
          
          echo "Catalog image verified (architecture: $ARCH)"
          echo "Note: Catalog image will be pulled by the cluster when CatalogSource is created"
          echo "If using a local image, it would need to be loaded into KIND:"
          echo "  kind load docker-image ${{ env.CATALOG_IMAGE }} --name ${{ env.CLUSTER_NAME }}"
          echo "Catalog image prepared"
      
      # Phase 5: Declarative OLM Deployment (Helm)
      - name: Create temp-manifests directory
        run: |
          set -e
          mkdir -p temp-manifests
          echo "temp-manifests directory created"
      
      - name: Render Helm chart
        run: |
          set -e
          echo "Rendering Helm chart..."
          if ! helm template toolhive-olm ./toolhive-olm-chart \
            --set catalogSource.image=${{ env.CATALOG_IMAGE }} \
            --set namespace.name=${{ env.OPERATOR_NS }} \
            --set operatorGroup.targetNamespaces[0]=${{ env.OPERATOR_NS }} \
            --set subscription.channel=stable \
            --set subscription.source=toolhive-test-catalog \
            --set subscription.sourceNamespace=openshift-marketplace \
            > temp-manifests/olm-resources.yaml; then
            echo "ERROR: Failed to render Helm chart"
            exit 1
          fi
          echo "Helm chart rendered"
          echo "--- Rendered manifests ---"
          cat temp-manifests/olm-resources.yaml
      
      - name: Split and apply resources in order
        run: |
          set -e
          echo "Splitting resources to apply in correct order..."
          
          # Clean up any existing split files
          rm -f temp-manifests/resource-*.yaml
          
          # Split YAML by document separator using awk (more reliable than csplit)
          # Handle both cases: file starting with --- or not
          awk '
            BEGIN { file=0; content="" }
            /^---$/ {
              if (content != "") {
                print content > "temp-manifests/resource-"file".yaml"
                file++
                content=""
              }
              next
            }
            { content = content $0 "\n" }
            END {
              if (content != "") {
                print content > "temp-manifests/resource-"file".yaml"
              }
            }
          ' temp-manifests/olm-resources.yaml
          
          # Remove empty files
          find temp-manifests -name "resource-*.yaml" -size 0 -delete
          
          echo "Split into $(ls -1 temp-manifests/resource-*.yaml 2>/dev/null | wc -l) resource files"
          
          # Apply CatalogSource first
          echo "Applying CatalogSource first..."
          CATALOG_APPLIED=false
          for file in temp-manifests/resource-*.yaml; do
            [ ! -f "$file" ] && continue
            if grep -q "kind: CatalogSource" "$file" 2>/dev/null; then
              oc apply -f "$file"
              echo "CatalogSource applied from $file"
              CATALOG_APPLIED=true
              break
            fi
          done
          
          if [ "$CATALOG_APPLIED" = "false" ]; then
            echo "WARNING: CatalogSource not found in split files, applying all resources"
            oc apply -f temp-manifests/olm-resources.yaml
          else
            # Apply Namespace and OperatorGroup (but not Subscription yet)
            echo "Applying Namespace and OperatorGroup..."
            for file in temp-manifests/resource-*.yaml; do
              [ ! -f "$file" ] && continue
              if grep -q "kind: Namespace\|kind: OperatorGroup" "$file" 2>/dev/null; then
                oc apply -f "$file" || true
              fi
            done
          fi
          
          echo "Initial resources applied (CatalogSource, Namespace, OperatorGroup)"
      
      - name: Wait for CatalogSource to be READY (OKD standard)
        run: |
          set -e
          echo "Waiting for CatalogSource to be READY (OKD openshift-marketplace namespace)..."
          echo "First, checking if catalog-operator is ready..."
          oc wait --for=condition=available --timeout=2m deployment/catalog-operator -n olm || echo "Warning: catalog-operator might not be fully ready"
          
          echo "Checking CatalogSource status..."
          oc get catalogsource toolhive-test-catalog -n openshift-marketplace -o yaml || echo "CatalogSource not found yet"
          
          echo "Waiting for CatalogSource pod to be created..."
          timeout 120 bash -c 'until oc get pods -n openshift-marketplace -l olm.catalogSource=toolhive-test-catalog 2>/dev/null | grep -q toolhive-test-catalog; do echo "Waiting for catalog pod..."; sleep 5; done' || echo "Catalog pod not created yet"
          
          echo "Checking catalog pod status..."
          oc get pods -n openshift-marketplace -l olm.catalogSource=toolhive-test-catalog || true
          
          # Monitor pod status and fail fast on CrashLoopBackOff
          echo "Monitoring catalog pod status (will fail fast on CrashLoopBackOff)..."
          MAX_WAIT=60  # Wait up to 60 seconds for pod to stabilize
          ELAPSED=0
          while [ $ELAPSED -lt $MAX_WAIT ]; do
          POD_STATUS=$(oc get pods -n openshift-marketplace -l olm.catalogSource=toolhive-test-catalog -o jsonpath='{.items[0].status.phase}' 2>/dev/null || echo "Unknown")
            RESTART_COUNT=$(oc get pods -n openshift-marketplace -l olm.catalogSource=toolhive-test-catalog -o jsonpath='{.items[0].status.containerStatuses[0].restartCount}' 2>/dev/null || echo "0")
            
          if [ "$POD_STATUS" = "CrashLoopBackOff" ] || [ "$POD_STATUS" = "Error" ]; then
              echo "ERROR: Catalog pod is in $POD_STATUS state (restart count: $RESTART_COUNT)"
              echo "Failing fast to avoid waiting for timeout..."
              
            echo "=== Catalog pod describe ==="
            oc describe pod -n openshift-marketplace -l olm.catalogSource=toolhive-test-catalog || true
              
            echo "=== CatalogSource pod logs (all containers) ==="
            oc logs -n openshift-marketplace -l olm.catalogSource=toolhive-test-catalog --all-containers=true --tail=100 || true
              
            echo "=== Previous container logs (if any) ==="
            oc logs -n openshift-marketplace -l olm.catalogSource=toolhive-test-catalog --previous --tail=100 || true
              
              # Check for architecture mismatch error
              LOGS=$(oc logs -n openshift-marketplace -l olm.catalogSource=toolhive-test-catalog --previous --tail=50 2>/dev/null || echo "")
              if echo "$LOGS" | grep -q "exec format error"; then
                echo ""
                echo "=========================================="
                echo "ARCHITECTURE MISMATCH DETECTED!"
                echo "The catalog image appears to be built for the wrong architecture."
                echo "Error: exec format error (typically means ARM image on AMD64 or vice versa)"
                echo ""
                echo "Solution: Rebuild the catalog image for linux/amd64 architecture"
                echo "Use the build-catalog workflow to rebuild:"
                echo "  .github/workflows/build-catalog.yaml"
                echo "=========================================="
              fi
              
            echo "=== Events in openshift-marketplace ==="
            oc get events -n openshift-marketplace --sort-by='.lastTimestamp' | tail -30 || true
              
              exit 1
            fi
            
            # If pod is running or pending, continue waiting
            if [ "$POD_STATUS" = "Running" ] || [ "$POD_STATUS" = "Pending" ] || [ "$POD_STATUS" = "ContainerCreating" ]; then
              echo "Pod status: $POD_STATUS (restart count: $RESTART_COUNT), continuing to wait..."
              sleep 5
              ELAPSED=$((ELAPSED + 5))
            else
              break
          fi
          done
          
          echo "Waiting for CatalogSource to become READY..."
          if ! oc wait --for=jsonpath='{.status.connectionState.lastObservedState}'=READY \
            catalogsource/toolhive-test-catalog -n openshift-marketplace \
            --timeout=${{ env.TEST_TIMEOUT }}; then
            echo "ERROR: CatalogSource did not become READY"
            echo "=== CatalogSource status ==="
            oc get catalogsource toolhive-test-catalog -n openshift-marketplace -o yaml
            echo "=== CatalogSource pods ==="
            oc get pods -n openshift-marketplace -l olm.catalogSource=toolhive-test-catalog
            echo "=== Catalog pod describe ==="
            oc describe pod -n openshift-marketplace -l olm.catalogSource=toolhive-test-catalog || true
            echo "=== CatalogSource pod logs (all containers) ==="
            oc logs -n openshift-marketplace -l olm.catalogSource=toolhive-test-catalog --all-containers=true --tail=100 || true
            echo "=== Previous container logs (if any) ==="
            oc logs -n openshift-marketplace -l olm.catalogSource=toolhive-test-catalog --previous --tail=100 || true
            echo "=== Catalog-operator logs ==="
            oc logs -n olm -l app=catalog-operator --tail=50 || true
            echo "=== Events in openshift-marketplace ==="
            oc get events -n openshift-marketplace --sort-by='.lastTimestamp' | tail -30 || true
            exit 1
          fi
          echo "CatalogSource is READY (OKD-compatible)"
      
      - name: Force catalog-operator to reconcile CatalogSource
        run: |
          set -e
          echo "Forcing catalog-operator to reconcile CatalogSource to ensure it's loaded into resolver cache..."
          
          # Verify CatalogSource is READY first
          CATALOG_READY=$(oc get catalogsource toolhive-test-catalog -n openshift-marketplace -o jsonpath='{.status.connectionState.lastObservedState}' 2>/dev/null || echo "")
          if [ "$CATALOG_READY" != "READY" ]; then
            echo "ERROR: CatalogSource is not READY (state: $CATALOG_READY)"
            exit 1
          fi
          
          echo "CatalogSource is READY, forcing reconciliation..."
          
          # Force reconciliation by adding/updating an annotation
          # This triggers the catalog-operator to reconcile the CatalogSource
          # and load it into the resolver cache
          oc annotate catalogsource toolhive-test-catalog -n openshift-marketplace \
            olm.cache.refresh="$(date +%s)" \
            --overwrite || {
            echo "WARNING: Failed to annotate CatalogSource, trying alternative method"
            # Alternative: patch the CatalogSource to trigger reconciliation
            oc patch catalogsource toolhive-test-catalog -n openshift-marketplace \
              --type merge -p '{"metadata":{"annotations":{"olm.cache.refresh":"'$(date +%s)'"}}}' || true
          }
          
          echo "CatalogSource annotated to trigger reconciliation"
          
          # Wait for catalog-operator to process the reconciliation
          echo "Waiting for catalog-operator to reconcile CatalogSource and load into resolver cache..."
          MAX_WAIT=90
          ELAPSED=0
          RECONCILED=false
          
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            # Check catalog-operator logs for reconciliation activity
            # Look for messages about syncing or processing our catalog
            if oc logs -n olm -l app=catalog-operator --tail=100 2>/dev/null | grep -q "toolhive-test-catalog"; then
              echo "Catalog-operator has processed toolhive-test-catalog in logs"
              RECONCILED=true
              # Give it additional time to update resolver cache
              echo "Waiting 20 seconds for resolver cache to be updated..."
              sleep 20
              break
            fi
            
            echo "Waiting for catalog-operator reconciliation... (${ELAPSED}s/${MAX_WAIT}s)"
            sleep 5
            ELAPSED=$((ELAPSED + 5))
          done
          
          if [ "$RECONCILED" != "true" ]; then
            echo "WARNING: Could not confirm catalog-operator has processed toolhive-test-catalog from logs"
            echo "Waiting additional 30 seconds to allow cache update..."
            sleep 30
          fi
          
          # Final wait to ensure resolver cache is fully updated
          echo "Final wait for resolver cache synchronization..."
          sleep 15
          
          echo "CatalogSource reconciliation complete - resolver cache should be updated"
      
      - name: Verify catalog is queryable
        run: |
          set -e
          echo "Verifying catalog is queryable and contains operators..."
          
          # Get catalog service endpoint
          CATALOG_SVC="toolhive-test-catalog.openshift-marketplace.svc:50051"
          CATALOG_POD=$(oc get pods -n openshift-marketplace -l olm.catalogSource=toolhive-test-catalog -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          
          if [ -z "$CATALOG_POD" ]; then
            echo "ERROR: Catalog pod not found"
            exit 1
          fi
          
          echo "Catalog pod: $CATALOG_POD"
          echo "Catalog service: $CATALOG_SVC"
          
          # Verify the catalog pod is actually serving
          echo "Checking if catalog pod is serving gRPC..."
          if oc exec -n openshift-marketplace $CATALOG_POD -- pgrep -f opm > /dev/null 2>&1; then
            echo "✓ Catalog pod process is running"
          else
            echo "WARNING: Could not verify catalog pod process"
          fi
          
          # Check if we can reach the service
          echo "Checking catalog service connectivity..."
          if oc run -n openshift-marketplace --rm -i --restart=Never --image=curlimages/curl:latest test-catalog-connect -- \
            curl -s http://toolhive-test-catalog.openshift-marketplace.svc:50051 > /dev/null 2>&1 || true; then
            echo "Catalog service is reachable (gRPC endpoint may require gRPC client)"
          fi
          
          echo "Catalog verification complete - ready for Subscription"
      
      - name: Verify operator exists in catalog
        run: |
          set -e
          echo "Verifying operator 'toolhive-operator' exists in catalog..."
          
          # Get catalog pod
          CATALOG_POD=$(oc get pods -n openshift-marketplace -l olm.catalogSource=toolhive-test-catalog -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          if [ -z "$CATALOG_POD" ]; then
            echo "ERROR: Catalog pod not found"
            exit 1
          fi
          
          echo "Catalog pod: $CATALOG_POD"
          echo "Checking catalog pod is running..."
          oc wait --for=condition=Ready pod/$CATALOG_POD -n openshift-marketplace --timeout=60s || {
            echo "WARNING: Catalog pod not ready, but continuing..."
          }
          
          # Check if catalog database exists (indicates indexing)
          # Based on our verification, the database is at /database/index.db
          echo "Verifying catalog database exists..."
          if oc exec -n openshift-marketplace $CATALOG_POD -- test -f /database/index.db 2>/dev/null; then
            echo "✓ Catalog database found at /database/index.db - catalog is indexed"
          elif oc exec -n openshift-marketplace $CATALOG_POD -- test -f /configs/index.db 2>/dev/null; then
            echo "✓ Catalog database found at /configs/index.db - catalog is indexed"
          else
            echo "WARNING: Catalog database not found in standard locations"
            echo "Checking alternative locations..."
            oc exec -n openshift-marketplace $CATALOG_POD -- find / -name "*.db" -type f 2>/dev/null | head -5 || true
            echo "WARNING: Catalog may not be properly indexed"
          fi
          
          echo "Catalog verification complete - CatalogSource is READY, operator should be resolvable"
          echo "Note: The actual operator resolution will be verified when Subscription is created"
      
      - name: Apply Subscription (after CatalogSource is READY)
        run: |
          set -e
          echo "Applying Subscription (CatalogSource is now READY and recognized by catalog-operator)..."
          
          # Delete existing Subscription if it exists (to recreate it fresh)
          oc delete subscription toolhive-operator -n ${{ env.OPERATOR_NS }} --ignore-not-found=true || true
          sleep 3
          
          # Verify CatalogSource is still READY and healthy
          echo "Verifying CatalogSource is still READY..."
          CATALOG_STATE=$(oc get catalogsource toolhive-test-catalog -n openshift-marketplace -o jsonpath='{.status.connectionState.lastObservedState}' 2>/dev/null || echo "Unknown")
          if [ "$CATALOG_STATE" != "READY" ]; then
            echo "WARNING: CatalogSource state is $CATALOG_STATE, expected READY"
            oc get catalogsource toolhive-test-catalog -n openshift-marketplace -o yaml
          else
            echo "✓ CatalogSource is READY"
          fi
          
          # Apply Subscription from split files
          SUBSCRIPTION_APPLIED=false
          for file in temp-manifests/resource-*.yaml; do
            [ ! -f "$file" ] && continue
            if grep -q "kind: Subscription" "$file" 2>/dev/null; then
              oc apply -f "$file"
              echo "Subscription applied from $file"
              SUBSCRIPTION_APPLIED=true
              break
            fi
          done
          
          if [ "$SUBSCRIPTION_APPLIED" = "false" ]; then
            echo "WARNING: Subscription not found in split files, applying from full manifest"
            # Extract Subscription using grep/awk as fallback
            awk '/^---$/{p=0} /kind: Subscription/{p=1} p' temp-manifests/olm-resources.yaml | oc apply -f - || {
              echo "ERROR: Failed to apply Subscription"
              exit 1
            }
          fi
          
          echo "Subscription applied"
          
          # Show Subscription status
          sleep 3
          echo "=== Subscription status ==="
          oc get subscription toolhive-operator -n ${{ env.OPERATOR_NS }} -o yaml || true
      
      - name: Wait for Subscription to resolve operator
        run: |
          set -e
          echo "Waiting for Subscription to resolve the operator from catalog..."
          echo "This ensures the catalog-operator's resolver has recognized the catalog"
          
          MAX_WAIT=300  # Wait up to 5 minutes for resolution (increased from 3 minutes)
          ELAPSED=0
          RESOLVED=false
          LAST_CATALOG_LOG_CHECK=0
          
          while [ $ELAPSED -lt $MAX_WAIT ]; do
            # Check Subscription conditions
            UNHEALTHY=$(oc get subscription toolhive-operator -n ${{ env.OPERATOR_NS }} -o jsonpath='{.status.conditions[?(@.type=="CatalogSourcesUnhealthy")].status}' 2>/dev/null || echo "")
            RESOLUTION_FAILED=$(oc get subscription toolhive-operator -n ${{ env.OPERATOR_NS }} -o jsonpath='{.status.conditions[?(@.type=="ResolutionFailed")].status}' 2>/dev/null || echo "")
            
            # Check if InstallPlan exists (indicates successful resolution)
            INSTALLPLAN_COUNT=$(oc get installplan -n ${{ env.OPERATOR_NS }} -l "operators.coreos.com/toolhive-operator.${{ env.OPERATOR_NS }}" --no-headers 2>/dev/null | wc -l || echo "0")
            
            if [ "$INSTALLPLAN_COUNT" -gt 0 ]; then
              echo "✓ InstallPlan created - operator resolved successfully!"
              RESOLVED=true
              break
            fi
            
            # If catalog is still reported as unhealthy, wait longer and check catalog-operator activity
            if [ "$UNHEALTHY" = "True" ] || [ "$RESOLUTION_FAILED" = "True" ]; then
              echo "Subscription still cannot resolve (${ELAPSED}s/${MAX_WAIT}s)..."
              echo "  CatalogSourcesUnhealthy: $UNHEALTHY"
              echo "  ResolutionFailed: $RESOLUTION_FAILED"
              
              # Every 30 seconds, check catalog-operator logs and CatalogSource status
              if [ $((ELAPSED - LAST_CATALOG_LOG_CHECK)) -ge 30 ]; then
                echo "  === Diagnostic check ==="
                echo "  Current Subscription conditions:"
                oc get subscription toolhive-operator -n ${{ env.OPERATOR_NS }} -o jsonpath='{.status.conditions[*].type}' 2>/dev/null | tr ' ' '\n' | while read type; do
                  status=$(oc get subscription toolhive-operator -n ${{ env.OPERATOR_NS }} -o jsonpath="{.status.conditions[?(@.type==\"$type\")].status}" 2>/dev/null || echo "")
                  reason=$(oc get subscription toolhive-operator -n ${{ env.OPERATOR_NS }} -o jsonpath="{.status.conditions[?(@.type==\"$type\")].reason}" 2>/dev/null || echo "")
                  message=$(oc get subscription toolhive-operator -n ${{ env.OPERATOR_NS }} -o jsonpath="{.status.conditions[?(@.type==\"$type\")].message}" 2>/dev/null || echo "")
                  echo "    $type: $status ($reason)"
                  if [ -n "$message" ]; then
                    echo "      Message: $message"
                  fi
                done || true
                
                echo "  CatalogSource status:"
                CATALOG_STATE=$(oc get catalogsource toolhive-test-catalog -n openshift-marketplace -o jsonpath='{.status.connectionState.lastObservedState}' 2>/dev/null || echo "Unknown")
                echo "    State: $CATALOG_STATE"
                
                echo "  Checking if catalog-operator has processed toolhive-test-catalog..."
                if oc logs -n olm -l app=catalog-operator --tail=100 2>/dev/null | grep -q "toolhive-test-catalog"; then
                  echo "    ✓ Found in catalog-operator logs"
                else
                  echo "    ✗ Not found in catalog-operator logs (catalog may not be loaded into resolver cache)"
                fi
                
                # Try to force another reconciliation if we're past 60 seconds
                if [ $ELAPSED -ge 60 ] && [ $((ELAPSED % 60)) -eq 0 ]; then
                  echo "  Forcing CatalogSource reconciliation again..."
                  oc annotate catalogsource toolhive-test-catalog -n openshift-marketplace \
                    olm.cache.refresh="$(date +%s)" \
                    --overwrite 2>/dev/null || true
                fi
                
                LAST_CATALOG_LOG_CHECK=$ELAPSED
              fi
            else
              echo "Subscription is processing... (${ELAPSED}s/${MAX_WAIT}s)"
            fi
            
            sleep 5
            ELAPSED=$((ELAPSED + 5))
          done
          
          if [ "$RESOLVED" != "true" ]; then
            echo "ERROR: Subscription failed to resolve operator after ${MAX_WAIT} seconds"
            echo ""
            echo "=== Full Diagnostic Information ==="
            echo ""
            echo "=== Subscription status ==="
            oc get subscription toolhive-operator -n ${{ env.OPERATOR_NS }} -o yaml
            echo ""
            echo "=== Subscription conditions (detailed) ==="
            oc get subscription toolhive-operator -n ${{ env.OPERATOR_NS }} -o jsonpath='{.status.conditions[*]}' || true
            echo ""
            echo ""
            echo "=== CatalogSource status ==="
            oc get catalogsource toolhive-test-catalog -n openshift-marketplace -o yaml
            echo ""
            echo "=== Catalog pod status ==="
            oc get pods -n openshift-marketplace -l olm.catalogSource=toolhive-test-catalog
            echo ""
            echo "=== Catalog-operator logs (last 100 lines) ==="
            oc logs -n olm -l app=catalog-operator --tail=100 || true
            echo ""
            echo "=== Catalog-operator logs (filtered for toolhive-test-catalog) ==="
            oc logs -n olm -l app=catalog-operator --tail=500 2>/dev/null | grep -i "toolhive" || echo "No mentions of toolhive in logs"
            echo ""
            echo "=== All CatalogSources ==="
            oc get catalogsource -A
            exit 1
          fi
          
          echo "Subscription has successfully resolved the operator"
      
      - name: Wait for operator installation (OKD OLM)
        run: |
          set -e
          echo "Waiting for InstallPlan to complete (OKD OLM)..."
          echo "Note: InstallPlan should already exist from previous step"
          
          # Verify InstallPlan exists (should have been created in previous step)
          INSTALLPLAN_COUNT=$(oc get installplan -n ${{ env.OPERATOR_NS }} -l "operators.coreos.com/toolhive-operator.${{ env.OPERATOR_NS }}" --no-headers 2>/dev/null | wc -l || echo "0")
          if [ "$INSTALLPLAN_COUNT" -eq 0 ]; then
            echo "ERROR: InstallPlan was not created (this should have been caught in previous step)"
            echo "=== Subscription status ==="
            oc get subscription toolhive-operator -n ${{ env.OPERATOR_NS }} -o yaml
            exit 1
          fi
          
          echo "InstallPlan found, waiting for it to complete..."
          
          # Now wait for InstallPlan to complete
          if ! timeout 300 bash -c 'until oc get installplan -n ${{ env.OPERATOR_NS }} -l "operators.coreos.com/toolhive-operator.${{ env.OPERATOR_NS }}" 2>/dev/null | grep -q Complete; do sleep 5; done'; then
            echo "ERROR: InstallPlan did not complete"
            echo "=== InstallPlan status ==="
            oc get installplan -n ${{ env.OPERATOR_NS }} -o yaml
            echo "=== InstallPlan describe ==="
            oc describe installplan -n ${{ env.OPERATOR_NS }} -l "operators.coreos.com/toolhive-operator.${{ env.OPERATOR_NS }}" || true
            echo "=== Subscription status ==="
            oc get subscription -n ${{ env.OPERATOR_NS }} -o yaml
            echo "=== Subscription conditions ==="
            oc get subscription toolhive-operator -n ${{ env.OPERATOR_NS }} -o jsonpath='{.status.conditions[*]}' || true
            echo ""
            exit 1
          fi
          echo "InstallPlan completed"
          
          echo "Waiting for CSV to be Succeeded (OKD OLM)..."
          if ! oc wait --for=jsonpath='{.status.phase}'=Succeeded \
            csv -n ${{ env.OPERATOR_NS }} \
            -l "operators.coreos.com/toolhive-operator.${{ env.OPERATOR_NS }}" \
            --timeout=${{ env.TEST_TIMEOUT }}; then
            echo "ERROR: CSV did not reach Succeeded phase"
            echo "CSV status:"
            oc get csv -n ${{ env.OPERATOR_NS }} -o yaml
            echo "CSV conditions:"
            oc get csv -n ${{ env.OPERATOR_NS }} -o jsonpath='{.items[*].status.conditions}' || true
            exit 1
          fi
          echo "CSV is Succeeded"
          
          echo "Waiting for operator deployment..."
          if ! oc wait --for=condition=available \
            deployment/toolhive-operator -n ${{ env.OPERATOR_NS }} \
            --timeout=${{ env.TEST_TIMEOUT }}; then
            echo "ERROR: Operator deployment did not become available"
            echo "Deployment status:"
            oc get deployment toolhive-operator -n ${{ env.OPERATOR_NS }} -o yaml
            echo "Deployment pods:"
            oc get pods -n ${{ env.OPERATOR_NS }} -l name=toolhive-operator
            echo "Pod logs:"
            oc logs -n ${{ env.OPERATOR_NS }} -l name=toolhive-operator --tail=50 || true
            exit 1
          fi
          echo "Operator deployment is available"
      
      # Phase 6: Declarative Validation and Testing (Chainsaw)
      - name: Run Chainsaw tests
        run: |
          set -e
          export KUBECONFIG=${HOME}/.kube/config
          echo "Running Chainsaw tests in namespace: ${{ env.OPERATOR_NS }}"
          if ! chainsaw test --test-dir ./test-suites --namespace ${{ env.OPERATOR_NS }}; then
            echo "ERROR: Chainsaw tests failed"
            echo "Collecting diagnostic information (OKD-compatible)..."
            oc get all -n ${{ env.OPERATOR_NS }}
            oc get mcpserver -n ${{ env.OPERATOR_NS }} || true
            exit 1
          fi
          echo "All Chainsaw tests passed"
      
      # Phase 7: Cleanup
      - name: Collect diagnostics on failure
        if: failure()
        run: |
          echo "=== Collecting diagnostic information (OKD-compatible) ==="
          echo "--- Cluster state ---"
          oc get all -A | grep -E "(toolhive|olm)" || true
          echo "--- OLM resources (OKD standard) ---"
          oc get catalogsource,subscription,operatorgroup,csv -A || true
          echo "--- Operator logs ---"
          oc logs -n ${{ env.OPERATOR_NS }} -l name=toolhive-operator --tail=100 || true
          echo "--- Events ---"
          oc get events -n ${{ env.OPERATOR_NS }} --sort-by='.lastTimestamp' | tail -20 || true
          echo "=== End diagnostics ==="
      
      - name: Cleanup OLM resources (OKD-compatible)
        if: always()
        run: |
          set +e
          echo "Cleaning up OLM resources (OKD-compatible)..."
          oc delete subscription toolhive-operator -n ${{ env.OPERATOR_NS }} --ignore-not-found=true || true
          oc delete operatorgroup toolhive-operator-group -n ${{ env.OPERATOR_NS }} --ignore-not-found=true || true
          oc delete catalogsource toolhive-test-catalog -n openshift-marketplace --ignore-not-found=true || true
          oc delete namespace ${{ env.OPERATOR_NS }} --ignore-not-found=true || true
          echo "Cleanup completed"
      
      - name: Delete KIND cluster
        if: always()
        run: |
          set +e
          kind delete cluster --name ${{ env.CLUSTER_NAME }} || true
          echo "KIND cluster deleted"

